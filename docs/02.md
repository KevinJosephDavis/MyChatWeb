接着我们完成注册、登录功能。

先检查是否安装gin：进入包含go.mod的那个目录，在该目录下打开终端，输入：go list -m all | grep gin

如果安装了，会显示类似如下内容的文本：

github.com/gin-contrib/sse v1.1.0
github.com/gin-gonic/gin v1.11.0

如果没有安装，输入：go get github.com/gin-gonic/gin

回车执行即可安装。

之前我们使用的是纯TCP模型，在这个项目中我们转向Gin的HTTP/WebSocket模型。之前的架构是TCP+自定义协议，我们自己定义数据包格式，实现了完全控制。但缺点是无法被浏览器访问（浏览器不能直接连TCP），需要单独开发桌面或手机客户端。Gin HTTP+WebSocket可以直接用网页作为客户端。为了平滑过渡，我们先保留现有结构，引入Gin

对`main.go`进行调整：

```go
package main

import (
	"fmt"
	"net"
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/kevinjosephdavis/chatroom/internal/service"
)

func handleConnection(conn net.Conn) {
	defer conn.Close()
	prc := &service.Processor{
		Conn: conn,
	}
	prc.Process()
}

func startTCPServer() {
	fmt.Println("服务器在8889端口监听...")
	listener, err := net.Listen("tcp", ":8889")
	if err != nil {
		fmt.Println("监听失败，错误信息：", err)
		return
	}
	defer listener.Close()

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println("接受连接失败，错误信息：", err)
			continue
		}
		go handleConnection(conn)
	}
}

func startHTTPServer() {
	fmt.Println("HTTP服务器在8080端口监听...")
	r := gin.Default()

	// 定义一个最简单的路由
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "pong",
		})
	})

	// 未来在这里添加注册、登录等路由
	// r.POST("/register", registerHandler)
	// r.POST("/login", loginHandler)

	// 启动HTTP服务器
	if err := r.Run(":8080"); err != nil {
		fmt.Println("HTTP服务器启动失败，错误信息：", err)
	}

}

func main() {
	// 方案一：同时运行两个服务器（用于测试）
	//go startTCPServer()
	//startHTTPServer()

	// 方案二：只运行TCP服务器
	// startTCPServer()

	// 方案三：只运行HTTP服务器
	startHTTPServer()
}
```

运行，可以在终端看见：

```bash
HTTP服务器在8080端口监听...
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /ping                     --> main.startHTTPServer.func1 (3 handlers)
[GIN-debug] [WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.
Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.
[GIN-debug] Listening and serving HTTP on :8080
[GIN] 2025/10/21 - 22:46:45 | 404 |       1.642µs |       127.0.0.1 | GET      "/Gin"
[GIN] 2025/10/21 - 22:46:45 | 404 |        1.01µs |       127.0.0.1 | GET      "/favicon.ico"
[GIN] 2025/10/21 - 22:46:56 | 200 |     137.335µs |       127.0.0.1 | GET      "/ping"
[GIN] 2025/10/21 - 22:46:56 | 404 |         937ns |       127.0.0.1 | GET      "/favicon.ico"
[GIN] 2025/10/21 - 23:24:14 | 200 |     366.751µs |       127.0.0.1 | GET      "/ping"

```

进入浏览器，输入`http://localhost:8080/ping`，可以看到message:"pong"

解释一下startHTTPServer()：

1.`r=gin.Default()`

返回一个带有日志和恢复中间件的标准引擎。这就如同给我们配备了一个服务员团队

2.`r.GET("/ping", func(c *gin.Context)){...}`

注册一个GET请求的路由。这相当于在餐厅的菜单上写下：菜单名：/ping | 点菜方式：GET | 厨师：后面的匿名函数。当有人访问/ping时，这个函数被调用。`c *gin.Context`是Gin最重要的对象，它封装了本次请求的所有信息和可用的操作。它包含了请求参数、请求头、设置响应、返回数据等。

我们可以将这个过程想象成打电话：

电脑（服务器）：像一家大公司，总机号码是`localhost:8080`

`r:=gin.Default()`：你为公司安装了一套智能电话交换机

`r.GET("/ping", ...) `：你在交换机上设置了一条转接规则：如果有电话打进来要找分机号ping，并且打电话的人说他是来咨询（GET）的，就把电话转接到某个客服

浏览器/客户端：像一个人拿起电话，拨打`localhost:8080/ping`，并对接线员说：我要咨询（GET）你们ping业务的信息。

也就是说，当我们在浏览器地址输入：`http://localhost:8080/ping`然后按回车，本质就是向`localhost:8080`这个地址的服务器，发送了一个HTTP GET请求，请求的路径是/ping

`*gin.Context`如同一次完整通话的档案袋，包含了这次交互的所有材料。当有人访问/ping时，Gin会创建一个Context对象，它里面包含：

请求参数（读）：

对方说了什么？（`c.Request.Body`，比如POST请求提交的用户名密码）

对方是谁？（`c.ClientIP()`，对方的IP地址）

对方想要什么？（`c.Request.URL`，请求的URL和查询参数）

对方的身份？（`c.GetHeader("Authorization")`，请求头里的身份令牌

设置响应（写）：

我该回什么话？（`c.JSON`、`c.String`，准备回复的内容）

用什么格式回？(`c.Header("Content-Type", "application/json")`，设置回复的格式)

回复时的表情？（`c.Status(200)`，设置HTTP状态码，200为成功，404为没找到，500为服务器错误）

所以，`c. *gin.Context`是我们在处理这次请求时，唯一需要操作的工作台，所有信息都在这里拿，所有回应都在这里发。

3.`c.JSON(200, gin.H{"message": "pong from Gin!",})`

`c.JSON`方法做了两件事：

a.设置HTTP状态码为200，即`http.StatusOK`（表示对方咨询的事情已经找到了）

b.设置通话内容（响应体）。即设置具体的回复内容为`message:pong`

而且它还会自动在HTTP响应头里加上：Content-Type: application/json; charset=utf-8

这是在告诉浏览器：我返回的内容是JSON格式的，要按照JSON的规则来解析。

如果你不用`c.JSON`而是直接打印pong，那么信息只会出现在服务器终端上，浏览器永远收不到。

`gin.H{}`是一个捷径，本质是`map[string]interface{}`



4.

```go
if err := r.Run(":8080"); err != nil {
    log.Fatal("HTTP服务器启动失败：",err)
}
```

启动服务器并开始监听。这个Run函数是阻塞的，持续处理到来的请求，直到强制停止程序。

错误处理：如果服务器启动失败（例如8080端口被占用），记录错误并退出程序。

完整的流程：

执行`go run main.go`，调用`startHTTPServer`函数。`r:=gin.Default()`创建了一个引擎，引擎里包含路由器和默认中间件。`r.GET("/ping",...)`注册了一条规则：如果有人用GET方法访问本机的/ping路径，就执行后面的匿名函数。程序会阻塞在`r.Run(":8080")`，开始在8080端口监听，如同服务员在门口等待客人。现在我们在浏览器输入`http://localhost:8080/ping`并回车。浏览器构造一个HTTP请求包，发送到电脑的8080端口。操作系统将网络数据包交给Go程序。Gin引擎接收到这个请求包，解析出它的方法（GET）和路径（/ping）。Gin根据之前注册的规则，执行对应的匿名函数。创建一个`*gin.Context`对象c， 这个c里已经装好了刚从请求包里解析出的信息。Gin调用匿名函数，并把刚创建好的c传给它。在匿名函数内部，执行`c.JSON(200, gin.H{"message": "pong"})`，这一行代码同时做了两件事：设置HTTP状态码为200，将`gin.H{"message": "pong"}`这个Go对象序列化成JSON格式的字节流`{"message": "pong"}`，并准备将其作为HTTP响应的body.此时响应还没有发回给浏览器，只是被写入了c这个上下文对象的缓冲区。匿名函数执行完毕。Gin引擎最后将c对象中已经设置好的状态码（200）和序列化好的JSON数据`{"message": "pong"}`按照HTTP协议的格式，组装成一个完整的HTTP响应包，通过操作系统发回给浏览器。浏览器收到HTTP响应包，先看状态码，发现是200（成功），于是再解析响应body里的JSON数据，最后在页面上显示出来。

关于`gin.H`，这是一个让我们少写代码的语法糖

```go
// gin.H 的本质就是一个 map[string]interface{}
type H map[string]interface{}

// 所以这行代码：
c.JSON(200, gin.H{"message": "pong"})

// 完全等价于：
data := map[string]interface{}{
    "message": "pong",
}
c.JSON(200, data)

// 也等价于你定义一个结构体：
type Response struct {
    Message string `json:"message"`
}
c.JSON(200, Response{Message: "pong"})
```





再来看几个Gin框架常见的API

1.路由定义：菜单清单

```go
// 处理不同HTTP方法
r.GET("/some-path", handlerFunction)      // 获取数据
r.POST("/some-path", handlerFunction)     // 创建数据 (如注册、登录)
r.PUT("/some-path", handlerFunction)      // 更新数据
r.DELETE("/some-path", handlerFunction)   // 删除数据

// 路径参数：从URL本身提取变量，适合用来获取用户ID
// 访问 /user/123， 在handler里可以通过 c.Param("id") 得到 "123"
r.GET("/user/:id", func(c *gin.Context) {
    userID := c.Param("id")
    c.JSON(200, gin.H{"user_id": userID})
})
```

2.请求解析：读懂客人的点菜单

```go
// 查询参数 
r.GET("/search", func(c *gin.Context) {
    query := c.Query("q")           // 得到 "Gin"
    page := c.DefaultQuery("page", "1") // 如果没传page参数，默认为 "1"
    c.JSON(200, gin.H{"q": query, "page": page})
})

// 解析JSON请求体 
type LoginRequest struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required"`
}

r.POST("/login", func(c *gin.Context) {
    var req LoginRequest
    // ShouldBindJSON 会自动将请求体中的JSON解析到 req 结构体
    // 如果JSON格式不匹配或缺少required字段，会返回错误
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "Invalid request"})
        return // 解析失败要立即返回，不再执行后面的逻辑
    }
    // 现在可以使用 req.Username 和 req.Password 
    c.JSON(200, gin.H{"message": "Login successful for " + req.Username})
})
```

解释一下这个`ShouldBindJSON`：

假设前端要注册一个新用户，它发送了一个HTTP POST请求，请求体（body）里是这样的JSON字符串：

```json
{
    "username": "kevin",
    "password": "123456",
    "email": "kevin@example.com"
}
```

而在我们的Go后端，我们希望用一个这样的结构体来操作这些数据

```go
type RegisterRequest struct {
    Username string
    Passrword string
    Email string
}
```

那么怎么把JSON字符串变成Go结构体呢？

如果是手动解析就比较繁琐，我们需要逐个字段提取并进行类型断言

```go
func registerHandler(c *gin.Context) {
    // 1. 从请求体中读取原始数据
    body, _ := ioutil.ReadAll(c.Request.Body)
    
    // 2. 手动解析JSON到map
    var data map[string]interface{}
    json.Unmarshal(body, &data)
    
    // 3. 逐个字段提取和类型断言
    username, _ := data["username"].(string)
    password, _ := data["password"].(string) 
    email, _ := data["email"].(string)
    
    // 4. 才能开始业务逻辑...
}
```

而使用`ShouldBindJSON`：

```go
type RegisterRequest struct {
    Username string `json:"username" binding:"required"`
    Password string `json:"password" binding:"required,min=6"`
    Email    string `json:"email" binding:"required,email"`
}

func registerHandler(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }
    
    // 现在可以直接使用 req.Username, req.Password, req.Email
    fmt.Printf("用户名: %s, 密码: %s, 邮箱: %s\n", req.Username, req.Password, req.Email)
}
```

`ShouldBindJSON`做了三个工作：

a.自动读取解析：自动从`c.Request.Body`读取原始的JSON字节流，自动将JSON字段映射到结构体字段，自动将JSON的字符串类型转换为Go的string类型。

b.字段映射：通过结构体标签

```go
`json:"username"` 
```

告诉Gin：JSON中的"username"字段映射到该结构体字段。如果没有这个标签，Gin会使用默认字段名Username去JSON中找对应的键。

c.数据验证：通过binding标签

```go
`binding:"required"`        // 该字段必须提供
`binding:"required,min=6"`  // 必须提供且最小长度6
`binding:"required,email"`  // 必须提供且符合邮箱格式
```



3.返回响应：给客人上菜

```go
// 返回JSON (最常用)
c.JSON(200, gin.H{"status": "success"})

// 返回纯文本
c.String(200, "Hello, World!")

// 返回HTML (未来渲染页面用)
// c.HTML(200, "index.html", gin.H{"title": "Home Page"})

// 返回错误状态码
c.JSON(400, gin.H{"error": "Bad Request"})
c.JSON(401, gin.H{"error": "Unauthorized"})
c.JSON(404, gin.H{"error": "Not Found"})
c.JSON(500, gin.H{"error": "Internal Server Error"})
```



接着我们在message.go中定义数据格式

```go
package message

const (
	MessageTypeText  = 1
	MessageTypeImage = 2
	MessageTypeFile  = 3
	MessageTypeVoice = 4
	MessageTypeVideo = 5
)

type LoginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

type RegisterRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required,min=6"`
	Email    string `json:"email" binding:"required,email"`
	Nickname string `json:"nickname,omitempty" `
}

type SendMessageRequest struct {
	SenderID    int64  `json:"sender_id" binding:"required"`
	ReceiverID  int64  `json:"receiver_id" binding:"required"`
	Content     string `json:"content" binding:"required"`
	MessageType int    `json:"message_type" binding:"required,oneof=1 2 3 4 5"`
	FileSize    int64  `json:"file_size,omitempty"`
	FileName    string `json:"file_name,omitempty"`
}

type BaseResponse struct {
	Code      int         `json:"code"`
	Message   string      `json:"message"`
	Data      interface{} `json:"data,omitempty"`
	Timestamp int64       `json:"timestamp"`
}

type LoginResponse struct {
	UserID    int64  `json:"user_id"`
	Username  string `json:"username"`
	Nickname  string `json:"nickname,omitempty"`
	Avatar    string `json:"avatar,omitempty"`
	Token     string `json:"token"`
	ExpiredAt int64  `json:"expired_at"` // Token过期时间
}

type RegisterResponse struct {
	UserID   int64  `json:"user_id"`
	UserName string `json:"username"`
	Email    string `json:"email"`
}

type SendMessageResponse struct {
	MessageID int64 `json:"message_id"`
	Timestamp int64 `json:"timestamp"`
	Status    int   `json:"status"` // 1-发送中 2-已送达 3-发送失败
}

type PageInfo struct {
	Page      int `json:"page"`       // 当前是第几页（从1开始）
	PageSize  int `json:"page_size"`  // 每页显示多少条
	Total     int `json:"total"`      // 总记录数
	TotalPage int `json:"total_page"` // 总页数
}

type ListResponse struct {
	BaseResponse
	PageInfo *PageInfo `json:"page_info,omitempty"`
}

```

解释几个点：

1.binding的作用

它是gin框架提供的数据验证机制，在数据进入业务逻辑之前进行检查。

常用的验证规则：

required：必须提供，不能为空

min/max：字符串最小/最大长度

gte/lte：数字大于等于/小于等于（greater than和less than）

email：必须是邮箱格式

url：必须是URL格式

oneof：必须是其中一员

ShouldBindJSON会自动执行binding验证。如果验证失败，错误信息会告诉你具体哪个字段不符合要求。

2.Token

Token（令牌）用于无状态身份验证。

传统方式（有状态）：用户登录后，服务器在内存中保存”已登录用户列表“。这就是之前我的那个简易聊天室的写法。

Token方式（无状态）：用户登录后，服务器发一个加密的身份证（Token），客户端自己保管

3.在数据库中ID一般是自增的整数或snowflake等长整型，因此我们将所有的ID的类型都设置为int64

4.PageInfo与ListResponse的作用：解决数据分页

如果聊天记录有10万条，前端请求不可能一次性返回，否则渲染卡顿+服务器压力大。分页就是把数据分成多个小块。ListResponse则是对分页数据的完整包装，例如：

```go
// 请求：GET /api/messages/history?page=1&page_size=20
func GetMessageHistory(c *gin.Context) {
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
	
	// 从数据库获取分页数据
	messages, total := messageRepo.GetMessages(page, pageSize)
	totalPage := (total + pageSize - 1) / pageSize // 计算总页数
	
	c.JSON(200, ListResponse{
		BaseResponse: BaseResponse{
			Code:      200,
			Message:   "success",
			Data:      messages, // 实际的消息列表
			Timestamp: time.Now().Unix(),
		},
		PageInfo: PageInfo{
			Page:      page,
			PageSize:  pageSize,
			Total:     total,
			TotalPage: totalPage,
		},
	})
}
```

要把ListResponse中的PageInfo字段设置成指针，是避免`omitempty`不起效果。因为零值结构体并不是nil

接着我们按照分层架构编写注册逻辑。

第一步：数据模型层

在`internal/repository/models/user.go`中：

```go
package model

import (
	"time"
)

type User struct {
	ID        int64     `gorm:"primaryKey;autoIncrement" json:"id"`
	Username  string    `gorm:"uniqueIndex;size:50;not null" json:"username"`
	Password  string    `gorm:"size:255;not null" json:"-"` // 密码字段不导出为JSON
	Email     string    `gorm:"size:100;uniqueIndex" json:"email"`
	Nickname  string    `gorm:"size:50" json:"nickname"`
	Avatar    string    `gorm:"size:255" json:"avatar"`
	Status    int8      `gorm:"default:1" json:"status"` // 1: active, 0: inactive
	CreatedAt time.Time `gorm:"autoCreateTime" json:"created_at"`
	UpdatedAt time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

```

定义数据库表对应的Go结构体



第二步：数据访问层

在`internal/repository/model/user_repo.go`中：

```go
package repository

import (
	"fmt"

	"github.com/kevinjosephdavis/chatroom/internal/repository/model"
	"gorm.io/gorm"
)

type UserRepository struct {
	db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository {
	return &UserRepository{db: db}
}

func (r *UserRepository) CreateUser(user *model.User) error {
	result := r.db.Create(user)
	if result.Error != nil {
		return fmt.Errorf("创建用户失败,err=%v", result.Error)
	}
	return nil
}

func (r *UserRepository) GetUserByUsername(username string) (*model.User, error) {
	var user model.User
	result := r.db.Where("username = ?", username).First(&user)
	if result.Error != nil {
		return nil, fmt.Errorf("根据用户名获取用户失败,err=%v", result.Error)
	}
	return &user, nil
}

func (r *UserRepository) GetUserByEmail(email string) (*model.User, error) {
	var user model.User
	result := r.db.Where("email=?", email).First(&user)
	if result.Error != nil {
		return nil, fmt.Errorf("根据邮箱获取用户失败,err=%v", result.Error)
	}
	return &user, nil
}

```

负责与数据库交互

将`r.db.where().First()`进行分解

```go
query := r.db.Where("username = ?", username) //设置查询条件
result := query.First(&user) //执行查询并取第一条
```

等价于：

```mysql
SELECT * FROM users WHERE username = 'username' LIMIT 1
```

GORM自动将返回的字段值赋给user结构体的对应字段。GORM是通过反射来匹配字段的，如果字段名不匹配，可以加tag，告诉GORM该字段对应数据库的哪一列。



第三步：业务逻辑层

在`internal/service/user_service.go`中：

```go
package service

import (
	"fmt"

	"github.com/kevinjosephdavis/chatroom/internal/repository"
	"github.com/kevinjosephdavis/chatroom/internal/repository/model"
	"golang.org/x/crypto/bcrypt"
)

type UserService struct {
	userRepo *repository.UserRepository
}

func NewUserService(userRepo *repository.UserRepository) *UserService {
	return &UserService{userRepo: userRepo}
}

// Register 注册新用户
func (s *UserService) Register(username, password, email, nickname string) (*model.User, error) {
	// 1.检查用户名是否已经存在
	existingUser, err := s.userRepo.GetUserByUsername(username)
	if err != nil {
		return nil, fmt.Errorf("检查用户名失败,err=%v", err)
	}
	if existingUser != nil {
		return nil, fmt.Errorf("用户名已存在")
	}

	// 2.检查邮箱是否已经存在
	existingUser, err = s.userRepo.GetUserByEmail(email)
	if err != nil {
		return nil, fmt.Errorf("检查邮箱失败,err=%v", err)
	}
	if existingUser != nil {
		return nil, fmt.Errorf("邮箱已存在")
	}

	// 3. 密码加密
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("密码加密失败,err=%v", err)
	}

	// 4. 创建用户
	user := &model.User{
		Username: username,
		Password: string(hashedPassword),
		Email:    email,
		Nickname: nickname,
		Status:   1,
	}
	if err := s.userRepo.CreateUser(user); err != nil {
		return nil, fmt.Errorf("创建用户失败,err=%v", err)
	}
	return user, nil
}

```

处理业务规则、密码加密等逻辑

`bcrypt.GenerateFromPassword`是密码学级别的哈希函数，专门用于安全地存储密码

如果明文存密码，那么数据库泄露时，攻击者就可以直接看到所有密码

`bcrypt.GenerateFromPassword`的第二个参数`bcrypt.DefaultCost`代表密码哈希的计算成本

Cost=4：快速但脆弱

Cost=10：平衡安全性与性能，也就是DefaultCost

Cost=14：非常安全但计算缓慢





第四步：控制器层

在`internal/controller/user_controller.go`中：

```go
package controller

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/kevinjosephdavis/chatroom/common/message"
	"github.com/kevinjosephdavis/chatroom/internal/service"
)

type UserController struct {
	userService *service.UserService
}

func NewUserController(userService *service.UserService) *UserController {
	return &UserController{userService: userService}
}

// Register 处理用户注册请求
func (ctrl *UserController) Register(c *gin.Context) {
	var req message.RegisterRequest

	// 1. 绑定并验证请求参数 
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, message.BaseResponse{
			Code:      400,
			Message:   "请求参数错误:" + err.Error(),
			Timestamp: time.Now().Unix(),
		})
		return
	}

	// 2. 调用业务逻辑
	user, err := ctrl.userService.Register(req.Username, req.Password, req.Email, req.Nickname)
	if err != nil {
		c.JSON(http.StatusBadRequest, message.BaseResponse{
			Code:      400,
			Message:   "注册失败:" + err.Error(),
			Timestamp: time.Now().Unix(),
		})
		return
	}

	// 3. 返回成功响应
	c.JSON(http.StatusOK, message.BaseResponse{
		Code:    200,
		Message: "注册成功",
		Data: message.RegisterResponse{
			UserID:   user.ID,
			UserName: user.Username,
			Email:    user.Email,
		},
		Timestamp: time.Now().Unix(),
	})
}

```

处理HTTP请求与响应

数据流向：

1.浏览器/Vue前端发送HTTP POST请求

2.Go的net/http包接收请求，解析头部信息

3.Gin框架创建`c *gin.Context`，其中包含`c.Request.Body`

4.`ShouldBindJSON`从`c.Request.Body`读取数据并解析





第五步：路由注册

在`cmd/api-server/main.go`中：

```go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/kevinjosephdavis/chatroom/internal/controller"
	"github.com/kevinjosephdavis/chatroom/internal/repository"
	"github.com/kevinjosephdavis/chatroom/internal/service"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func startHTTPServer() {
	fmt.Println("HTTP服务器在8080端口监听...")

	// 1.初始化数据库
	dsn := "username:password@tcp(localhost:3306)/chatroom?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal("数据库连接失败，错误信息：", err)
		return
	}

	// 2.自动创建表
	//db.AutoMigrate() 暂时注释，设计好所有表结构再打开

	// 3.初始化各层组件
	userRepo := repository.NewUserRepository(db)
	userService := service.NewUserService(userRepo)
	userController := controller.NewUserController(userService)

	// 4.创建Gin引擎
	r := gin.Default()

	// 5.注册路由
	api := r.Group("/api")
	{
		api.POST("/register", userController.Register)
		// 其他用户相关路由如登录等可以在这里继续添加
	}

	//6.添加测试路由
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "pong from gin!",
		})
	})

	//启动HTTP服务器
	if err := r.Run(":8080"); err != nil {
		fmt.Println("HTTP服务器启动失败，错误信息：", err)
	}

}

func main() {
	startHTTPServer()
}

```

将所有组件组装起来

dsn，全称为：Data Source Name，是数据库的连接字符串。将它分解：

```go
	dsn := "username:password@tcp(localhost:3306)/chatroom?charset=utf8mb4&parseTime=True&loc=Local"
```

username:password -> 数据库用户名和密码

@tcp(localhost:3306) -> 协议和地址（本地MySQL的3306端口）

chatroom -> 要连接的数据库名

?charset=utf8mb4 -> 字符集（支持emoji）

&parseTime=true -> 自动解析时间字段

&loc = local -> 使用本地时区

```go
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
```

mysql.Open(dsn)：使用MySQL驱动打开连接，好比找到MySQL这栋大楼的地址（dsn）

&gorm.Config{}：gorm的配置选项

gorm.Open：接管连接并进行初始化，好比进入大楼之后配置办公设备

返回的db对象可以与数据库交互

















